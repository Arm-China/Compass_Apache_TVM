# SPDX-License-Identifier: Apache-2.0
# Copyright (c) 2023 Arm Technology (China) Co. Ltd.
"""Build AIPU Compass function for running through AIPU Compass Driver."""
import time
import numpy as np
from tvm import nd
from tvm.aipu.logger import DEBUG
from ..codegen import CodeGenAipuCompass
from ..config import AipuCompassFunctionConfig
from .engine import AipuForwardEngine
from ..aipu_builder import check_call_aipu_tool
from ..utils import relative_symlink_in_dir, create_aipu_compass_module


class CompassDriverMotor(AipuForwardEngine):
    """Build AIPU Compass function for running through AIPU Compass Driver."""

    def pre_build(self, func):
        """Build the AIPU Compass function to run on AIPU Compass Driver before
        Relay build the whole model."""
        cfg = AipuCompassFunctionConfig(func.attrs.global_symbol)
        # 1. Get the Compass IR from Relay IR and write them to disk.
        t_start = time.perf_counter()
        DEBUG("relay to compass ir start")
        CodeGenAipuCompass().gen2file(func, *cfg.compass_ir_path)
        DEBUG("relay to compass ir finished. elapsed time: %.2fs", time.perf_counter() - t_start)

        # 2. Simplify Compass float IR through "aipugsim" if needed.
        if cfg.use_gsim_float:
            # Create symbolic links that point to Compass IR in AIPU gsim_float directory.
            src_paths = (*cfg.compass_ir_path, cfg.auto_fuse_plugin_dir)
            relative_symlink_in_dir(src_paths, cfg.gsim_float_work_dir)
            try:
                t_start = time.perf_counter()
                DEBUG("GSim compass ir start.")
                check_call_aipu_tool(cfg.gsim_cmd("float"), cfg.gsim_float_work_dir)
                DEBUG(
                    "GSim compass ir finished. elapsed time: %.2fs", time.perf_counter() - t_start
                )
            except:  # pylint: disable=bare-except
                cfg.gsim_float_ir_path = cfg.compass_ir_path

        # 3. Get the quantized Compass IR through "aipuopt".
        # Create symbolic links that point to Compass IR(gsim) in AIPU Optimizer directory.
        float_ir_path = cfg.gsim_float_ir_path if cfg.use_gsim_float else cfg.compass_ir_path
        src_paths = (*float_ir_path, cfg.auto_fuse_plugin_dir)
        relative_symlink_in_dir(src_paths, cfg.optimizer_work_dir)
        t_start = time.perf_counter()
        DEBUG("aipu backend quantization start")
        check_call_aipu_tool(cfg.optimizer_cmd, cfg.optimizer_work_dir)
        DEBUG(
            "aipu backend quantization finished. elapsed time: %.2fs", time.perf_counter() - t_start
        )

        # 4. Simplify Compass quant IR through "aipugsim".
        # Create symbolic links that point to quantized Compass IR in AIPU gsim_quant directory.
        src_paths = (*cfg.quant_compass_ir_path, cfg.auto_fuse_plugin_dir)
        relative_symlink_in_dir(src_paths, cfg.gsim_quant_work_dir)
        try:
            t_start = time.perf_counter()
            DEBUG("GSim compass quant ir start.")
            check_call_aipu_tool(cfg.gsim_cmd("quant"), cfg.gsim_quant_work_dir)
            DEBUG(
                "GSim compass quant ir finished. elapsed time: %.2fs", time.perf_counter() - t_start
            )
        except:  # pylint: disable=bare-except
            cfg.gsim_quant_ir_path = cfg.quant_compass_ir_path

        # 5. Generate library implementation of the auto fused operators.
        from ..transform import generate_op_lib_impl  # pylint: disable=import-outside-toplevel

        generate_op_lib_impl(cfg.auto_fuse_lib_dir, target=cfg.target)

        # 6. Get the AIPU executable(i.e., aipu.bin) through "aipugb".
        # Create symbolic links that point to quantized Compass IR(gsim) in AIPU GBuilder directory.
        src_paths = (*cfg.gsim_quant_ir_path, cfg.auto_fuse_plugin_dir, cfg.auto_fuse_lib_dir)
        relative_symlink_in_dir(src_paths, cfg.gbuilder_work_dir)
        DEBUG("aipu backend codegen start")
        t_start = time.perf_counter()
        check_call_aipu_tool(cfg.gbuilder_cmd, cfg.gbuilder_work_dir)
        DEBUG("aipu backend codegen finished. elapsed time: %.2fs", time.perf_counter() - t_start)

        aipu_bin = np.fromfile(cfg.gbuilder_output_file, dtype="uint8")
        try:
            # Try to obtain the NDArray object without memory copy.
            aipu_bin = nd.from_dlpack(aipu_bin)
        except:  # pylint: disable=bare-except
            aipu_bin = nd.array(aipu_bin)

        # Embed the pre-build result into Relay IR through attribute of function.
        return func.with_attr("compass.pre_build.aipu_bin", aipu_bin)

    def build(self, func):
        """Create the AIPU Compass runtime module with the pre-build result
        during Relay build the whole model."""
        func_name = func.attrs.global_symbol

        # Create symbolic link that point to graph.json which is generated by GBuilder when enable
        # profile in runtime directory, so simulator can used it to print the layer information.
        cfg = AipuCompassFunctionConfig(func_name)
        relative_symlink_in_dir(f"{cfg.gbuilder_work_dir}/graph.json", cfg.runtime_work_dir)

        # Get the pre-build result back from Relay IR.
        aipu_bin = func.attrs["compass.pre_build.aipu_bin"]

        return create_aipu_compass_module(aipu_bin, func_name)
