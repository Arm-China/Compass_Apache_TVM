// SPDX-License-Identifier: Apache-2.0
// Copyright (c) 2023-2024 Arm Technology (China) Co. Ltd.
/*!
 * \file aipu/src/runtime/compass/sim/driver.cc
 */
#include <aipu/runtime/compass/basic_config.h>
#include <aipu/runtime/compass/driver.h>
#include <aipu/runtime/utils.h>

namespace tvm {
namespace runtime {

static inline std::string GetSimulatorPath(const Map<String, String>& rt_cfg, std::string target) {
  auto itr = rt_cfg.find("simulator");
  if (itr != rt_cfg.end()) return (*itr).second;
  if (!(StrStartsWith(target, "X1_") || StrStartsWith(target, "Z2_"))) return "";
  std::string exec_name = "aipu_simulator_" + StrLower(target.substr(0, 2));
  const char* path_env = std::getenv("PATH");
  if (path_env != nullptr) {
    for (const auto& path : StrSplit(path_env, ":")) {
      std::string full_path = path + "/" + exec_name;
      if (IsExecutable(full_path)) return full_path;
    }
  }

  LOG(FATAL) << "Can't find the executable \"" << exec_name
             << "\", please ensure its path is contained in environment variable \"PATH\".";
  throw;  // unreachable, written to stop compiler warning
}

void AipuDriver::ConfigGlobal(bool is_profile) {
  aipu_global_config_simulation_t cfg = {0};
  const Map<String, String>& rt_cfg = AipuCompassBasicConfig::Global()->runtime;
  std::string sim_path = GetSimulatorPath(rt_cfg, target_);
  cfg.simulator = sim_path.c_str();
  if (!(StrStartsWith(target_, "X1_") || StrStartsWith(target_, "Z2_"))) {
    cfg.npu_arch_desc = target_.c_str();
    cfg.simulator = nullptr;
  }
  cfg.log_level = 0;  // Use simulator's environment variable "SIM_LOG_LEVEL" if needed.
  cfg.verbose = rt_cfg["verbose"] == "true";
  cfg.en_eval = is_profile;

  status_ = aipu_config_global(ctx_, AIPU_CONFIG_TYPE_SIMULATION, &cfg);
  AIPU_DRIVER_HANDLE_ERROR(status_);
  return;
}

void AipuDriver::ConfigEnvItems() {
  // Only set the environment variable if it doesn't exist.
  if (umd_dtcm_sz_ != "") setenv("UMD_DTCM_SZ", umd_dtcm_sz_.c_str(), 0);
  if (!(StrStartsWith(target_, "X1_") || StrStartsWith(target_, "Z2_"))) ConfigGlobal(false);
  return;
}

void AipuDriver::ConfigGraphItems() {
  uint32_t buffer_cnt = 0;
  status_ = aipu_get_tensor_count(ctx_, graph_id_, AIPU_TENSOR_TYPE_PROFILER, &buffer_cnt);
  AIPU_DRIVER_HANDLE_ERROR(status_);
  bool en_eval = buffer_cnt != 0;

  if (StrStartsWith(target_, "X2_")) {
    // need to set en_eval again because X2 umd will new a simulator instance
    // when load the graph, then here call aipu_config_global is invalid.
    status_ = aipu_ioctl(ctx_, AIPU_IOCTL_SET_PROFILE, &en_eval);
    AIPU_DRIVER_HANDLE_ERROR(status_);
    return;
  }
  ConfigGlobal(en_eval);
  return;
}

void AipuDriver::ConfigJobItems() {
  aipu_job_config_simulation_t cfg = {0};
  cfg.data_dir = work_dir_.c_str();

  status_ = aipu_config_job(ctx_, job_id_, AIPU_CONFIG_TYPE_SIMULATION, &cfg);
  AIPU_DRIVER_HANDLE_ERROR(status_);
  return;
}

void AipuDriver::Run() {
  // The files generated by AIPU simulator only will be placed to the current
  // directory, so change the current directory to the working directory
  // temporarily.
  std::string old_cur_dir = GetCwd();
  ChDir(work_dir_);

  status_ = aipu_finish_job(ctx_, job_id_, -1);
  AIPU_DRIVER_HANDLE_ERROR(status_);

  ChDir(old_cur_dir);
  return;
}

void AipuDriver::DumpProfileData() { return; }

}  // namespace runtime
}  // namespace tvm
