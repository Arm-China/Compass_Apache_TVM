<!---SPDX-License-Identifier: Apache-2.0-->
<!---Copyright (c) 2023-2024 Arm Technology (China) Co. Ltd.-->

# How to Interact with Python

This section describes how to interact with Python in the Compass DSL. We will first elaborate on what interacting with Python entails, and then illustrate this with two specific examples in the following content. Finally, we will provide notes to be taken when interacting with Python.

## What is Interacting with Python

The interaction with Python means that in Compass DSL:

- You can leverage components from Python's ecosystem, such as third-party packages like NumPy.
- You can use tools like `pdb` or `breakpoint` to [debug programs written in Compass DSL](./how_to_debug_with_python.md).
- You can use instances from Python as inputs, intermediate computations, or outputs for Compass DSL programs.

The most commonly used form of interaction is computation, that is, through Python function. Therefore, all the examples in this section primarily use functions as the form of interaction.

To ensure the correctness of the interaction results with Python, we need to follow the steps below:

1. Complete the writing of the Compass DSL program, which include pure Python functions without `S.prim_func` decorated. These functions serve as the form of interaction.
2. Compile the program. Call the `build` method of the `BuildManager` class to complete the compilation of the DSL program.
3. Check the compilation results. Open the product directory, whose name starts with `compass_dsl_func_`, go into the `gbuilder/op_lib` under the directory, and you can see the OpenCL code generated by the previous compilation step.

The interaction of pure Python functions occurs during the compilation of program, and the results of the interaction can be obtained by viewing the OpenCL code, such as the execution results of a certain pure Python function.

## Example: Generate Offline Lookup Table

In one implementation of the SILU operator, an offline lookup table is required, and we can generate the lookup table at compile time by interacting with Python.

The function `gen_silu_lut` is a pure Python function and `S.alloc_const` means allocating a `__constant` buffer on OpenCL and its value is determined by the return value of `gen_silu_lut`.

```py
def gen_silu_lut(lut_len, lut_edge, dtype):
    # Key points of FP16 LUT generation:
    # 1. lut_x[-lut_edge, lut_edge]
    # 2. dytpe = "float16"
    # 3. pad the lut_table with the last element (lut_edge)
    x = np.linspace(-lut_edge, lut_edge, lut_len - 1)
    n = lut_len - 1
    lut = np.zeros((n,), dtype=dtype)
    for i in range(n):
        lut[i] = x[i] / (1 + np.exp(-x[i]))
    lut.resize(lut_len)
    lut[-1] = lut_edge
    return lut

@S.prim_func
def silu_fp16(
    in0: S.ptr(dtype, "global"),
    out0: S.ptr(dtype, "global"),
    n: S.i32,
):
    lut = S.alloc_const((lut_len,), dtype, gen_silu_lut(lut_len, lut_edge, dtype))
    ...
```

This function `gen_silu_lut` above would be running on the host side during the compile time. Therefore, the function's body will not be included in the OpenCL code, only the return value will be retained as below.

```c
__constant uchar __attribute__((aligned(32))) silu_fp16_u8_lut[1024] = {
    0x70, 0x8f, 0xb5, 0x8f, 0xfb, 0x8f, 0x22, 0x90, 0x48, 0x90, 0x70, 0x90, 0x98, 0x90, 0xc2, 0x90,
    0xee, 0x90, 0x1b, 0x91, 0x4a, 0x91, 0x7a, 0x91, 0xac, 0x91, 0xe0, 0x91, 0x16, 0x92, 0x4e, 0x92,
    // ...
    0xe2, 0x48, 0xe7, 0x48, 0xec, 0x48, 0xf1, 0x48, 0xf6, 0x48, 0xfb, 0x48, 0x00, 0x49, 0x00, 0x49
};

__kernel void silu_fp16(__global half* in0, __global half* out0, int n) {
  __lsram half16 lsram_ptr_buf[1024];
  __constant half* lut = (__constant half*)silu_fp16_u8_lut;
  __lsram half16* lsram_ptr = lsram_ptr_buf;
  // ...
}
```

The requirement here is about lookup table, which can be generated offline. The inputs and computation process of the function are all within the scope of pure Python environment.

## Example: Unify Simple but Numerous Branches

Another case has a special computation, which has simple but numerous branches, and can be determined at compile time.

These simple but numerous branches can be included in a pure Python function as shown below.

```py
def compute_area(area_type, a):
    if area_type == 1:  # square
        return a * a
    if area_type == 2:  # circle
        return 3.1415 * a * a
    # other branches ...
    # ...
    return 0

@S.prim_func
def func(inp: S.ptr("fp32", "global"), out: S.ptr("fp32", "global")):
    out[0] = compute_area(1, 5)
    out[1] = compute_area(2, 10)
    out[2] = compute_area(3, 10)
    # ...
```

Because the subfunction `compute_area` is not decorated, the function's body will not be included in the OpenCL code as shown below, only the return value will be retained. Moreover, the computation of this function is completed at compile time, we can see the result of `compute_area` in OpenCL code:

```c
__kernel void func(__global float* inp, __global float* out) {
  out[0] = 2.50000000000000000e+01f;
  out[1] = 3.14150000000000034e+02f;
  out[2] = 0.00000000000000000e+00f;
  // ...
  barrier(CLK_LOCAL_MEM_FENCE);
}
```

The requirement here are that the logic to be computed is simple but involves numerous branches. Moreover, the computation can be performed offline.

## Note

However, it should be noted that pure Python functions are evaluated at compile-time, and their results should not be confused with runtime variables when in use. Otherwise, the OpenCL code may be unexpected. Here, non-pure-Python refers to variables whose values are determined at runtime.

Below, let's look at an example where the error is caused by the user's confusion between runtime and compile-time parameters.

```py
# Here a and b are variables from S.pointer,
# and cannot be used (compare) with pure Python
# zero values at compile time. This is a misuse.
def mul(a, b):
  if a != 0 and b != 0:
    return a * b
  return 0

@S.prim_func
def func(inp: S.ptr("int8", "global"), out: S.ptr("int8", "global")):
    out[0] = mul(inp[0], inp[1])
```

The example above shows the input variable coming from `S.pointer` (non-pure-Python elements) of function `mul`. The input variables `a` and `b` are compared with `0`. The OpenCL code is unexpected: the `if` statement is lost as shown below.

```c
__kernel void func(__global char* inp, __global char* out) {
  out[0] = (char)(inp[0] * inp[1]);
  barrier(CLK_LOCAL_MEM_FENCE);
}
```

Because the input variables are non-pure Python elements whose values are determined at runtime, the interaction of pure Python functions occurs at compile time. These unreasonable calculations occur at compile time, which may subsequently result in incorrect OpenCL code.

To fix this issue, runtime computation is required, meaning the subfunction must be decorated with `S.prim_func`. This decoration marks the function as a primitive function and enables the generation of OpenCL code for it as shown below.

```py
@S.prim_func  # required
def mul(a: S.int8, b: S.int8) -> S.int8:
    if a != 0 and b != 0:
        return a * b
    return 0

@S.prim_func
def func(inp: S.ptr("int8", "global"), out: S.ptr("int8", "global")):
    out[0] = mul(inp[0], inp[1])
```

The OpenCL code for the function `func_mul` can now be correctly generated. As a result, the function is no longer a pure Python function and will not be evaluated at compile time. Instead, its variable inputs will participate in the computation at runtime, as expected.

```c
char func_mul(char a, char b) {
  if ((a != (char)0) && (b != (char)0)) {
    return (char)(a * b);
  }
  return 0;
}

__kernel void func(__global char* inp, __global char* out) {
  out[0] = func_mul(inp[0], inp[1]);
  barrier(CLK_LOCAL_MEM_FENCE);
}
```

## Summary

The Compass DSL can interact with pure Python at compile time to save runtime overhead. However, it's necessary to remember that compile-time operations are unaware of runtime variable values. Therefore, when interacting with Python, ensure that all inputs and computations are within the scope of pure Python environment.
